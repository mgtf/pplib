#!/usr/bin/perl -w
#
# PHPXref v0.2
#
# A utility for cross referencing PHP script files
#
# (c) 2000,2001 Gareth Watts  <gareth@omnipotent.net>
#
# Contributors:
# Gottfried Szing <goofy@yasd.dhs.org>
#
# Usage: phpxref.pl [-c <config file>]
# Looks for config.cfg in the script directory by default
#
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#
# CUSTOMIZNG
# ----------
# If you want to change the way that the comments are parsed, you
# just need to edit a few lines in this script.
# Have a look around line 390 and you'll see what I mean
# (it ain't purdy but it's simple enough)
# or just search for the word CUSTOM in caps


$version="0.2";


#### Configurable bits - Best place to change this stuff is in the config file


# Default header/footer - override here or by using -t / -b
$rundate=localtime();
$pageheader="<HTML><HEAD><TITLE>__TITLE__</TITLE></HEAD><BODY BGCOLOR=\"#FFFFFF\">\n";
$pagefooter="<BR><HR><TABLE WIDTH=100%><TR><TD>Generated: $rundate</TD><TD ALIGN=\"RIGHT\"><I>Generated by PHPXref $version</I></TD></TR></TABLE></BODY></HTML>\n";

# PHP Servers to link to for documentation
@phpsites=('php.net','uk.php.net','au.php.net:81','de.php.net');
	
# config defaults
%config=(
	'js_bg1'		=> '#000000',	# Background of the search box header
	'js_fg1'		=> '#FFFFFF',	# Text colour in the search box header
	'js_bg2'		=> '#EEEEEE',	# Background of the search box
	'col_comments'	=> '#555555',	# Colour used to display comment lines in the source view
	'col_linenum'	=> '#555555',	# Colour used to display line numbers in the source view
	'source_font'	=> 'Clean',		# Font to use in the source view
	'info_bg1'		=> '#DDDDDD',	# Background for the function information title box
	'info_bg2'		=> '#EEEEEE'	# Background for the function information box
);	

my $dbh = 0;	# used for table references

#### Less configurable stuff hereon in (take a sick bag; this code hasn't so much evolved, as gone rotten)

use File::Find;
use File::Path;
use File::Basename;
use File::Copy;
use Getopt::Std;


$scriptbase=dirname($0);
getopts('c:') || usage_die();

$debug=0;
$|=1;
$opt_c="$scriptbase/config.cfg" unless $opt_c;
parse_config($opt_c) || die "Error parsing config file";
$output_dir=$config{'output'} || die "No OUTPUT directory specified";
$source_dir=$config{'source'} || die "No SOURCE directory specified";
$ext=defined($config{'extension'}) ? $config{'extension'} : 'html';

chomp($pwd=`pwd`);
unless ($output_dir =~ m|^/|) {
	$output_dir="$pwd/$output_dir";
}

unless ($source_dir =~ m|^/|) {
	$source_dir="$pwd/$source_dir";
}
$source_dir =~ s|/+$||;

print "PHPXref $version running..\n";

if ($config{'headerfile'}) { # read header
	open(HEADER,$config{'headerfile'}) || die "Error opening header file ".$config{'headerfile'}." for read: $!";
	$pageheader=join('',<HEADER>);
	$pageheader =~ s/__VERSION__/$version/g;
	$pageheader =~ s/__RUNDATE__/$rundate/g;
	$pageheader .="\n<!-- Generated by PHPXref $version at $rundate -->\n";
	$pageheader .="<!-- PHPXref (c) 2000,2001 Gareth Watts - gareth\@omnipotent.net -->\n";
	$pageheader .="<!-- http://phpxref.sourceforge.net/ -->\n\n";
	close(HEADER);
}
if ($config{'footerfile'}) { # read footer
	open(FOOTER,$config{'footerfile'}) || die "Error opening footer file ".$config{'footerfile'}." for read: $!";
	$pagefooter=join('',<FOOTER>);
	$pagefooter =~ s/__VERSION__/$version/g;
	$pagefooter =~ s/__RUNDATE__/$rundate/g;
	close(FOOTER);
}
if ($config{'db_use'} eq 'YES')
{
	my $db_host	= $config{'db_host'};
	my $db_port	= $config{'db_port'};
	my $db_name	= $config{'db_name'};
	my $db_user	= $config{'db_user'};
	my $db_pass	= $config{'db_pass'};

	require DBI;
	require DBI::DBD;

	$dbh     = DBI->connect("DBI:mysql:database=$db_name;host=$db_host;port=$db_port",$db_user,$db_pass);
}

if (length($config{'functionlist'})) { read_functions($config{'functionlist'}); }

# Copy a few icons
mkpath("$output_dir/_icons");
copy("$scriptbase/folder.gif","$output_dir/_icons/folder.gif");
copy("$scriptbase/text.gif","$output_dir/_icons/text.gif");


print "Source............: $source_dir\n";
print "Target............: $output_dir\n";
print "Scanning Tree.....: ";

find(\&tagfile,$source_dir);

foreach $path (keys %allfiles) {
	$path =~ m|^(.*?)([^/]+)$|;
	($subdir,$filename)=($1,$2);
	$subdir =~ s|/+$||;
	scanfile($subdir,$filename);
}
	
print "\nGenerating Output.: ";

# Generate frame navigation bar
open(DIRTREE,">$output_dir/navframe.$ext") || die "Error opening $target/nav.$ext for write: $!";
print DIRTREE "<html><body bgcolor=\"#ffffff\">\n";
print DIRTREE "<b>PHPXref $version</b><p>\n";
gendir_recurse("/",0);
sub gendir_recurse {
	my ($path,$depth) = @_;
	return unless defined($dirtree{$path});
	foreach my $subdir (sort @{$dirtree{$path}}) {
		print DIRTREE ("&nbsp;&nbsp;"x$depth)."<a href=\".$path$subdir/index.$ext#filelist\" target=\"docview\">$subdir</a><br>\n";
		gendir_recurse("$path$subdir/",$depth+1);
	}
}
print DIRTREE "</body></html>\n";
close(DIRTREE);

# Generate top level frame
open(FRAMEHOLDER,">$output_dir/nav.$ext") || die "Error opening $target/nav.$ext for write: $!";
print FRAMEHOLDER <<__FRAME__;
<html>
<head>
<title>PHPXref $version</title>
</head>
<frameset cols="15%,*">
	<frame name="nav" src="navframe.$ext" marginwidth=1 marginheight=1>
	<frame name="docview" src="index.$ext">
	<noframes>
		No frames? 
		Don't worry - <a href="index.$ext">click here to view the main index; you're not missing too much ;-)</a>
	</noframes>
</frameset>
</html>
__FRAME__
close(FRAMEHOLDER);

foreach $parent (keys %alldirs) {
	# print child dirs
	($debug) && print "parent: $parent\n";
	my $depth=getdepth($parent);
	my $relroot="../" x $depth;
	$target=$output_dir.$parent;
	mkpath($target);
	# Sub-directory list
	open(INDEX,">$target/index.$ext") || die "Error opening $target/index.$ext for write: $!";
	my $newheader=$pageheader;
	$newheader =~ s/__TITLE__/$parent/g;
	print INDEX $newheader;
	print INDEX javascript_search($depth);
	print INDEX "<font size=\"-1\">";
	print INDEX "[ <a href=\"${relroot}nav.$ext\" target=\"_top\">Show Navbar</a> ] ";
	print INDEX "[ <a href=\"index.$ext\" target=\"_top\">Hide Navbar</a> ]";
	print INDEX "</font><p>\n";
	print INDEX "<H3>$parent</H3>\n";
	print INDEX "<PRE>\n";
	if ($depth) {
		print INDEX '<IMG SRC="'.$relroot.'_icons/folder.gif" ALT="Folder"> <A HREF="../index.'.$ext.'">Up one level</A>'."\n";
	}
	if (defined($dirtree{$parent})) {
		foreach $child (sort @{$dirtree{$parent}}) {
			print INDEX '<IMG SRC="'.$relroot.'_icons/folder.gif" ALT="Folder"> <A HREF="'.uri_encode($child).'/index.'.$ext.'">'.$child."/</A>\n";
		}
	}
	if (defined($files{$parent})) {
		print INDEX "<hr>\n";
		print INDEX "<font size=\"-1\"><a name=\"filelist\">Filelist</a></font><p>\n";
		# File list
		foreach $file (sort @{$files{$parent}}) {
			print ".";
			print INDEX "<TABLE CELLSPACING=0 CELLPADDING=0 BGCOLOR=\"".$config{'filename_bg'}."\" WIDTH=100%><TR><TD>\n";
			print INDEX "<TABLE>";
			print INDEX "<TR><TD ROWSPAN=2 VALIGN=\"TOP\">";
			print INDEX '<IMG SRC="'.$relroot.'_icons/text.gif" ALT="File"> ';
			print INDEX "</TD><TD XWIDTH=1%>\n";
			print INDEX "<PRE><A HREF=\"$file.$ext\">$file</A>";
			if (length($file)<26) { $spaces=30-length($file); } else { $spaces=0; }
			print INDEX ' 'x$spaces;
			#print INDEX "</PRE></TD><TD>";
			print INDEX "<FONT SIZE=-2>";
			print INDEX "[<A HREF=\"".uri_encode($file).".source.$ext\">source</A>]";
			$size=sprintf('%d lines (%dkb)',$fileinfo{"$parent$file"}{'lines'},$fileinfo{"$parent$file"}{'size'}/1000+.5);
			print INDEX " [$size]". ' 'x(20-length($size));
			print INDEX "</FONT></TD></TR>\n";
			print INDEX "<TR>";#<TD>&nbsp;</TD>";
			print INDEX "<TD>&nbsp;&nbsp;&nbsp;<B>$description</B></TD></TR>" if $description=$fileinfo{"$parent$file"}{'description'};
			print INDEX "</TABLE>\n";
			print INDEX "</TD></TR></TABLE>\n";
			&processpage($parent,$file);
			#&xrefpage($parent,$file);
		}
	}
	print INDEX "</PRE>\n";
	print INDEX $pagefooter;
	close(INDEX);
}

print "\n";
generate_references();
print "\nDone.\n";

	
sub process_table_list {
	my ($tlist)=@_;
	my ($table);
	my @tables=split(/[, ]+/,$tlist);
	foreach $table (@tables) {
		push(@{$table_references{$table}},
			{
			'subdir'	=> "$subdir/",
			'filename'	=> $filename,
			'line'		=> $line
			}
		);
		$filetables{"$subdir/$filename"}{$table}=1;
		if (!$table_ids{$table}) {
			$table_ids{$table}=uri_encode($table);
		}
	}
}

# collapse '.' and '..' entries in a path name
sub collapse_path {
	my ($path)=@_;

	$path =~ s|/{2,}|/|g; 
	my @elements=split("/",$path);
	my @outelements=();
	FELOOP:foreach $element (@elements) {
		if ($element eq '.') {
			next FELOOP;
		}
		if ($element eq '..') {
			if (scalar(@outelements)>0) {
				pop(@outelements);
			}
			next FELOOP;
		}
		push(@outelements,$element);
	}
	return(join('/',@outelements));
}

sub resolve_require {
	my ($reqname)=@_;
	if (substr($reqname,0,1) ne "/") {
		foreach $p (@includepath) {
			if ($p eq ".") { 
				$pn="$subdir/$reqname";
			} elsif ($p =~ m|^[^/]|) {
				$pn="$subdir/$p/$reqname";
			} else {
				$pn="$p/$reqname";
			}
			$pn =~ s|/+|/|;
			$pn=collapse_path($pn);
			if ($allfiles{$pn}) {
				return($pn);
			}
		}
	}
	return("");
}

sub process_require {
	my ($reqname)=@_;
	return unless $pn=resolve_require($reqname);
	push(@{$require_references{$pn}},
		{
		'subdir'	=> "$subdir/",
		'filename'	=> $filename,
		'line'		=> $line
		}
	);
	$filerequires{"$subdir/$filename"}{$pn}=1;
	#print "filerequires{\"$subdir/$filename\"}{$pn}=1;\n";
}


##################################################################
sub tagfile {
	my $fext;
	$scanfile_filename=$_;
	$findbase=$File::Find::topdir;
	$subdir=substr($File::Find::dir,length($findbase)-0);
	$dirname=substr($subdir,rindex($subdir,'/')+1);
	if (-d $_)  { 
		if ($bad_dirnames{$_} || $bad_pathnames{"$subdir/$_"}) {
			$File::Find::prune = 1;
			$_=$scanfile_filename;
			return;
		}
		($debug) && print "DIR: $_\n"; 
		($debug) && print "Got subdir = '$subdir'\n";
		push(@{$dirtree{"$subdir/"}},$_);
		if ($_ eq '.') {
			$alldirs{"$subdir/"}=1;
		} else {
			$alldirs{"$subdir/$_/"}=1;
		}
		$_=$scanfile_filename;
		return;
	}
	do {$_=$scanfile_filename;return;} unless (-f $_);
	do {$_=$scanfile_filename;return;} unless (-T $_); # Check that it's a text file
	do {$_=$scanfile_filename;return;} if (defined($config{'no_hidden'}) && substr($_,0,1) eq '.'); # reject hidden files
	do {$_=$scanfile_filename;return;} if $bad_filenames{$_};
	if (/\.([^.]+)$/) {
		$fext=$1;
		do {$_=$scanfile_filename;return;} if $bad_extensions{$fext};
	}
	if (defined(%good_extensions)) {
		do {$_=$scanfile_filename;return;} unless defined($fext);
		do {$_=$scanfile_filename;return;} unless defined($good_extensions{$fext});
	}
	$filename=$_;
	$allfiles{"$subdir/$filename"}=1;
	$_=$scanfile_filename;
}


sub scanfile {
	my ($subdir,$filename)=@_;
	print ".";
	open(SFILE,"$source_dir$subdir/$filename") || die "Error opening $source_dir$subdir/$filename for read: $!";
	$state="NONE";
	($debug) && print "Find::dir = ".$File::Find::dir."\n";
	($debug) && print "Findbase = $findbase\n";
	#$subdir = $subdir ? $subdir : "__TOP__";
	my ($description,$comment,$briefcomment)=("","","");
	$line=0;
	$author="";
	while(<SFILE>) {
		chomp;
		$line++;
		m|^\s*// TABLES:\s*(.*)| && process_table_list($1);
		m%\b(require|include|require_once|include_once)\s{0,1}\({0,1}\s{0,1}["']([^'"]+)["']% && process_require($2);
		if ($state eq "NONE") {
			# CUSTOM: Detect the beginning of a function comment block ( '////' by default)
			m|^\s*////$| && ($state="COMMENT");

			# CUSTOM: Get the description of the file we're looking at 
			# you usually have this once at the top of the file
			if(m|^\s*// $filename - author:\s*(.*)|) { $author =$1 } 
			else {(m|^\s*// $filename -\s*(.*)| && ($description.=$1));}
		} elsif ($state eq "COMMENT") {
			# CUSTOM: Get the short description of the function
			if (m|^\s*//\s*!(.*)|) {
				$briefcomment=$1;
			# CUSTOM: or the fuller description
			} elsif (m|^\s*//\s*(.*)|) {
				$comment.="$1\n";
			} 
		}
		if (m|^\s*function|i) {
			$state="FUNCTION";
		} 
		if ($state eq "FUNCTION") {
			if (!$function && /^\s*function\s+(\w+)\s*\(([^)]*)(.*)$/i) {
				$function=lc($1); #function names are case insensitive
				$functionline=$line;
				chomp($funcargs=$2);
				$remainder=$3;
				if (index($remainder,')')>-1) {
					$funcdone=1;
				}
			} elsif ($function && /^([^)]*)(.*)$/) { # function split across lines 
				chomp($funcargs.=$1);
				$remainder=$2;
				if (index($remainder,')')>-1) {
					$funcdone=1;
				}
			}
			if ($funcdone) {
				$funcdone=0;
				$funcargs =~ s/\s+/ /g;
				push(@{$func_definitions{$function}},
					{
					'subdir' => $subdir,
					'filename' => $filename,
					'args' => $funcargs,
					'briefcomment' => $briefcomment,
					'comment' => $comment,
					'line'	=> $functionline
					}
				);
				push(@{$filefunctions{"$subdir/$filename"}},
					{
					'name'	=> $function,
					'args'	=> $funcargs,
					'briefcomment'	=> $briefcomment,
					'comment'	=> $comment,
					'line'	=> $functionline
					}
				);
				if (!$func_ids{$function}) {
					$func_ids{$function}=uri_encode($function);
				}
				$function=$funcargs=$comment=$briefcomment="";
				$state="NONE";
			}
		}
	}
	@stat=stat(SFILE);
	close(SFILE);
	push(@{$files{"$subdir/"}},$filename);
	$fileinfo{"$subdir/$filename"}{'filename'}=$filename;
	$fileinfo{"$subdir/$filename"}{'description'}=$description;
	$fileinfo{"$subdir/$filename"}{'author'}=$author;
	$fileinfo{"$subdir/$filename"}{'lines'}=$line;
	$fileinfo{"$subdir/$filename"}{'size'}=$stat[7];
	$fileinfo{"$subdir/$filename"}{'ctime'}=$stat[10];
	$files{"$subdir/$filename"}=$description;
}

sub processpage {
	my ($subdir,$filename)=@_;


	($debug) && print "Processing $filename in $subdir\n";
	$htmldir="$output_dir/$subdir";
	my $depth=getdepth($subdir);
	$relroot="../" x (getdepth($subdir));
	($debug) && print "htmldir = $htmldir\n";
	unless (-d $htmldir) {
		mkpath($htmldir) || die "Error creating directory $htmldir: $!";
	}
	my $pagefile="$htmldir/$filename.$ext";
	open(FILEINFO,">$pagefile") || die "Error opening $pagefile for write: $!";
	my $newheader=$pageheader;
	$newheader =~ s/__TITLE__/Detail view of $filename/g;
	my ($toplinks,$funcbody)=("","");
	print FILEINFO $newheader;
	print FILEINFO javascript_search($depth);
	print FILEINFO "<BR>Directory: <A HREF=\"./index.$ext\">$subdir</A><BR>\n";
	print FILEINFO "<H1>$filename</H1>\n";
	if (length($fileinfo{"$subdir$filename"}{"author"})) {
		print FILEINFO "Author(s): ".$fileinfo{"$subdir$filename"}{"author"} ."<BR><BR>\n<P>\n";
	} else {
		print FILEINFO "Author(s): (none)<BR><BR>\n";
	}
	if (length($description)) {
		print FILEINFO "<B>".formatstr($description)."</B><BR><BR>\n<P>\n";
	} else {
		print FILEINFO "<I>(no description)</I><BR><BR>\n";
	}
	print FILEINFO $fileinfo{"$subdir$filename"}{"lines"}." lines ";
	print FILEINFO "<FONT SIZE=-1>[<A HREF=\"$filename.source.$ext\">source</A>]</FONT><BR>\n";
	if ($require_references{"$subdir$filename"}) {
		print FILEINFO "<P>Referenced ";
		print FILEINFO "<A HREF=\"$filename.xref.$ext\">";
		print FILEINFO scalar(@{$require_references{"$subdir$filename"}})." times</A><BR>\n";
	} else {
		print FILEINFO "<P>Not referenced by any other file<BR>\n";
	}
	print FILEINFO "<P>\n";
	if (defined($filefunctions{"$subdir$filename"})) {
		($debug) && print "filefunctions{$subdir/$filename}\n";
		$funcbody="<HR><BR>\n<H3>Function Guide</H3>\n";
		foreach $functionref (@{$filefunctions{"$subdir$filename"}}) {
			$funcname=$functionref->{'name'};
			if (!$func_ids{$funcname}) {
				$func_ids{$funcname}=uri_encode($funcname);
			}
			$toplinks.="<LI><A HREF=\"#$funcname\">$funcname</A>()</LI>\n";

			$args=formatstr($functionref->{"args"});
			$args =~ s/\$\{{0,1}(\w+)/"<A HREF=\"${relroot}_variables\/".uri_encode($1).".$ext\">\$$1<\/A>"/eg;
			$funcbody.="<TABLE BORDER=0><TR BGCOLOR=\"$config{'info_bg1'}\"><TD>\n";
			$funcbody.="<A NAME=\"$funcname\" HREF=\"$filename.source.$ext#l".$functionref->{"line"}."\"><FONT SIZE=+1><B>$funcname</B></FONT></A>($args)&nbsp;&nbsp;\n";
			$funcbody.="<A HREF=\"${relroot}_functions/".$func_ids{$funcname}.".$ext\"><FONT SIZE=-1>X-Ref</FONT></A>\n";
			$funcbody.="</TD></TR><TR BGCOLOR=\"$config{'info_bg2'}\"><TD>";
			if (length($functionref->{"briefcomment"})||length($functionref->{"comment"})) {
				$funcbody.="<B>".formatstr($functionref->{"briefcomment"})."</B><BR>";
				$funcbody.=formatstr($functionref->{"comment"});
			} else {
				$funcbody.="<I>No description</I>";
			}
			$funcbody.="</TD></TR></TABLE>\n\n";
			$funcbody.="<BR><BR>\n";
			#$body.="</UL><BR><BR>\n";
		}
		print FILEINFO "Defines the following functions: <BR>\n<UL>\n";
		print FILEINFO $toplinks;
		print FILEINFO "</UL>\n";
		#print FILEINFO "</UL><HR><BR>\n";
		#print FILEINFO $body;
	} else {
		print FILEINFO "No functions defined in this file<BR>\n";
	}
	my $ti=0;
	if ($filetables{"$subdir$filename"}) {
		print FILEINFO "<P>References the following tables: <BR>\n<UL>\n";
		foreach $table (sort keys %{$filetables{"$subdir$filename"}}) {
			print FILEINFO "<LI><A HREF=\"${relroot}_tables/".$table_ids{$table}.".$ext\">$table</A></LI>\n";
		}
		print FILEINFO "</UL><BR>\n";
	}
	if ($filerequires{"$subdir$filename"}) {
		print FILEINFO "<P>References the following files: <BR>\n<UL>\n";
		foreach $reqfile (keys %{$filerequires{"$subdir$filename"}}) {
			$reqfile =~ s|^/+||;
			print FILEINFO "<LI><A HREF=\"${relroot}$reqfile.$ext\">$reqfile</A></LI>\n";
		}
		print FILEINFO "</UL><BR>\n";
	} 
	print FILEINFO "$funcbody\n";
	print FILEINFO $pagefooter;
	close(FILEINFO);

	if ($require_references{"$subdir$filename"}) {
		$xreffile="$htmldir/$filename.xref.$ext";
		open(FILEXREF,">$xreffile") || die "Error opening $xreffile for write: $!";
		$newheader=$pageheader;
		$newheader =~ s/__TITLE__/Require cross reference for $filename/g;
		print FILEXREF $newheader;
		print FILEXREF javascript_search($depth); 
		print FILEXREF "<BR>Directory: <A HREF=\"./index.$ext\">$subdir</A><BR>\n";
		print FILEXREF "<H1><A HREF=\"$filename.$ext\">$filename</A></H1>\n";
		print FILEXREF "Referenced ".scalar(@{$require_references{"$subdir$filename"}})." times:<BR>\n";
		print FILEXREF "<UL>\n";
		foreach $xref (@{$require_references{"$subdir$filename"}}) {
			$file=$xref->{'filename'};
			$fs=$xref->{'subdir'};
			$line=$xref->{'line'};
			$fs =~ s|^/+||;
			$fs =~ s|/+$||;
			print FILEXREF "<LI>";
			print FILEXREF "<A HREF=\"${relroot}$fs/$file.$ext\">$fs/$file</A>";
			print FILEXREF " -> <A HREF=\"${relroot}$fs/$file.source.$ext#l$line\">line $line</A>";
			print FILEXREF "</LI>\n";
		}
		print FILEXREF "</UL>\n";
		print FILEXREF $pagefooter;
		close(FILEXREF);
	}

	open(SOURCE,"$source_dir/$subdir/$filename") || die "Error opening source: $!";
	open(SYNTAX,">$htmldir/$filename.source.$ext") || die "Error opening syntax target: $!";
	$line=1; 
	$newheader=$pageheader;
	$newheader =~ s/__TITLE__/$subdir$filename source/g;
	print SYNTAX $newheader;
	print SYNTAX javascript_search($depth);
	print SYNTAX "<FONT FACE=\"Clean\" SIZE=-2>\n";
	print SYNTAX "<A HREF=\"./index.$ext\">$subdir</A> -> <A HREF=\"$filename.$ext\">$filename</A><BR><P>\n";
	while(<SOURCE>) {
		$strformatted=0;
		if (m%\b(require|include|require_once|include_once)\s{0,2}\({0,1}\s{0,2}['"](.+)['"]%i) {
			$type=$1;
			if ($reqpath=resolve_require($2)) {
				$reqpath =~ s|^/+||;
				s|(\b$type\s{0,2}\({0,2}['"])(.+)(['"])|formatstr($1)."<A HREF=\"${relroot}$reqpath.$ext\">".formatstr($2)."</A>".formatstr($3)|ie;
				$_.="<br>\n";
				$strformatted=1;
			}
		} 
		if (!$strformatted) {
			formatstr($_);
		}
			
		$relroot="../" x (getdepth($subdir));
		chomp;
		undef %refed;
		if (/^#|^\/\//) {  # comment
			$_="<FONT FACE=\"$config{'source_font'}\" SIZE=-2 COLOR=\"$config{'col_comments'}\">$_</FONT>";
		} else {
			while (/\$\{{0,1}(\w+)\s*=[^=]/g) {
				push(@{$var_definitions{$1}},
					{
					'subdir'	=> $subdir,
					'filename'	=> $filename,
					'line'		=> $line
					}
				);
				$refed{$1}=1; # avoid picking up an entry twice
				if (!$var_ids{$1})  {
					$var_ids{$1}=uri_encode($1);
				}
			}
			while (/\$\{{0,1}(\w+)/g) {
				if (!$refed{$1}) {
					push(@{$var_references{$1}},
						{
						'subdir'	=> $subdir,
						'filename'	=> $filename,
						'line'		=> $line
						}
					);
				}
				if (!$var_ids{$1})  {
					$var_ids{$1}=uri_encode($1);
				}
			}
			while (/\b(\w+)\s*\(/g) {
				$funcname=lc($1); # treat without case sensitivity
				push(@{$func_references{$funcname}},
					{
					'subdir'	=> $subdir,
					'filename'	=> $filename,
					'line'		=> $line
					}
				);
				if (!$func_ids{$funcname}) {
					$func_ids{$funcname}=uri_encode($funcname);
				}
			}
			#s/\$\{{0,1}(\w+)/<A HREF="${relroot}vars.$ext#$1">\$$1<\/A>/g;
			s/\$\{{0,1}(\w+)/<A HREF="${relroot}_variables\/$var_ids{$1}.$ext">\$$1<\/A>/g;
			s/\b(\w+)\(/"<A HREF=\"${relroot}_functions\/".$func_ids{lc $1}.".$ext\">$1<\/A>\("/ge;
		}
		print SYNTAX "<A NAME=\"l$line\"><FONT SIZE=-2 COLOR=\"$config{'col_linenum'}\">$line</FONT>&nbsp;</A> ";
		print SYNTAX $_."\n";
		$line++;
	}
	print SYNTAX "</FONT>\n";
	print SYNTAX $pagefooter;
	close(SYNTAX);
	close(SOURCE);
}

sub generate_references {
	# Generate variable references
	print "Generating variable references: ";
	mkpath("$output_dir/_variables");
	my $v=0;
	foreach $varname (sort(keys %var_ids)) {
		(!($v % 10)) && (print ".");
		$v++;
		if (defined($var_definitions{$varname})) {
			push(@varlist_defs,$varname);
		} else {
			push(@varlist_other,$varname);
		}
		open(VARINDEX,">$output_dir/_variables/".$var_ids{$varname}.".$ext")|| die "Error opening $output_dir/_variables/".$var_ids{$varname}.".$ext for write: $!";
		my $varnameid=$var_ids{$varname};
		my $newheader=$pageheader;
		$newheader =~ s/__TITLE__/Variable Reference: \$$varname/g;
		print VARINDEX $newheader;
		print VARINDEX javascript_search(1);
		print VARINDEX "[<A HREF=\"../index.$ext\">Top level directory</A>]<BR>\n";
		print VARINDEX "<H3>Variable Cross Reference</H3>\n";
		print VARINDEX "<H2><A HREF=\"index.$ext#$varnameid\">\$$varname</A></H2><BR><BR>\n\n";
		if (defined($var_definitions{$varname})) {
			print VARINDEX "<B>Defined at..</B><UL>\n";
			foreach $def (@{$var_definitions{$varname}}) {
				print VARINDEX "<LI>";
				print VARINDEX "<A HREF=\"..".$def->{'subdir'}.$def->{'filename'}.".$ext\">";
				print VARINDEX $def->{'subdir'}.$def->{'filename'}."</A> ";
				print VARINDEX " -> ";
				print VARINDEX "<A HREF=\"..".$def->{'subdir'}.$def->{'filename'}.".source.$ext#l".$def->{'line'}."\">";
				print VARINDEX " line ".$def->{'line'}."</A>";
				print VARINDEX "</LI>\n";
			}
			print VARINDEX "</UL>\n";
		}
		if (defined($var_references{$varname})) {
			print VARINDEX "<BR><B>Referenced ".scalar(@{$var_references{$varname}})." times..</B><UL>\n";
		} else {
			print VARINDEX "<BR><B>No definitions found</B><BR><BR>\n";
		}
		foreach $ref (@{$var_references{$varname}}) {
			print VARINDEX "<LI>";
			print VARINDEX "<A HREF=\"..".$ref->{'subdir'}.$ref->{'filename'}.".$ext\">";
			print VARINDEX $ref->{'subdir'}.$ref->{'filename'}."</A> ";
			print VARINDEX " -> ";
			print VARINDEX "<A HREF=\"..".$ref->{'subdir'}.$ref->{'filename'}.".source.$ext#l".$ref->{'line'}."\">";
			print VARINDEX " line ".$ref->{'line'}."</A>";
			print VARINDEX "</LI>\n";
		}
		print VARINDEX "</UL>\n";
		print VARINDEX $pagefooter;
		close(VARINDEX);
	}

	# Generate variable index
	open(INDEX,">$output_dir/_variables/index.$ext") || die "Error opening $output_dir/variables.$ext for write: $!";
	my $newheader=$pageheader;
	$newheader =~ s/__TITLE__/Full Variable Index/g;
	print INDEX $newheader;
	print INDEX "[<A HREF=\"../index.$ext\">Top level directory</A>] ";
	print INDEX " &nbsp;&nbsp;&nbsp; ";
	print INDEX "[<A HREF=\"../_functions/index.$ext\">Functions</A>]";
	print INDEX " &nbsp;&nbsp;&nbsp; ";
	print INDEX "[<A HREF=\"../_tables/index.$ext\">Tables</A>]";
	print INDEX "<BR>\n";
	print INDEX "<H2>Variable List (alphabetical)</H2>\n";
	print INDEX "<FONT SIZE=+1>\n";
	print INDEX "Total unique variables names: <B>".scalar(keys %var_ids)."</B><UL>\n";
	if (defined(@varlist_defs)) {
		print INDEX "<LI><A HREF=\"#DEF\">Variables defined on the site</A>: <B>".scalar(@varlist_defs)."</B></LI>\n";
	}
	if (defined(@varlist_other)) {
		print INDEX "<LI><A HREF=\"#OTHER\">Other Variables</A>: <B>".scalar(@varlist_other)."</B></LI>\n";
	}
	print INDEX "</UL>\n";
	print INDEX "</FONT>\n";
	if (scalar(@varlist_defs)) {
		print INDEX "<A HREF=\"#top\" NAME=\"DEF\">";
		print INDEX "<B>Variables defined on the site</B>";
		print INDEX "</A><UL>\n";
		foreach $varname (@varlist_defs) {
			$varnameid=$var_ids{$varname};
			print INDEX "<LI>";
			print INDEX "<A NAME=\"$varnameid\" HREF=\"$varnameid.$ext\">\$$varname</A>";
			print INDEX "&nbsp;&nbsp;<FONT SIZE=-1>Definitions: <B>".scalar(@{$var_definitions{$varname}});
			print INDEX "&nbsp; </B>References: <B>".scalar(@{$var_references{$varname}})."</B></FONT>"; 
			print INDEX "</LI>\n";
		}
		print INDEX "</UL><BR>\n";
	}
	if (scalar(@varlist_other)) {
		print INDEX "<A HREF=\"#top\" NAME=\"OTHER\">";
		print INDEX "<B>Other variables</B>";
		print INDEX "</A><UL>\n";
		foreach $varname (@varlist_other) {
			$varnameid=$var_ids{$varname};
			print INDEX "<LI>";
			print INDEX "<A NAME=\"$varnameid\" HREF=\"$varnameid.$ext\">\$$varname</A>";
			print INDEX "&nbsp;&nbsp;<FONT SIZE=-1>References: <B>".scalar(@{$var_references{$varname}})."</B></FONT>";
			print INDEX "</LI>\n";
		}
		print INDEX "</UL><BR>\n";
	}
	print INDEX $pagefooter;
	close(INDEX);

	# Generate function references
	print "\nGenerating function references: ";
	mkpath("$output_dir/_functions");
	my $f=0;
	foreach $funcname (sort(keys %func_ids)) {
		(!($f % 10)) && (print ".");
		$f++;
		open(FUNCINDEX,">$output_dir/_functions/".$func_ids{$funcname}.".$ext")|| die "Error opening $output_dir/_functions/".$func_ids{$funcname}.".$ext for write: $!";
		my $funcnameid=$func_ids{$funcname};
		if ($php_functions{$funcname}) {
			push(@funclist_php,$funcname);
		} elsif (defined($func_definitions{$funcname}) && scalar(@{$func_definitions{$funcname}})) {
			push(@funclist_defs,$funcname);
		} else {
			push(@funclist_other,$funcname);
		}
		my $newheader=$pageheader;
		$newheader =~ s/__TITLE__/Function Reference: $funcname\(\)/g;
		print FUNCINDEX $newheader;
		print FUNCINDEX javascript_search(1);
		print FUNCINDEX "[<A HREF=\"../index.$ext\">Top level directory</A>]<BR>\n";
		print FUNCINDEX "<H3>Function Cross Reference</H3>\n";
		print FUNCINDEX "<H2><A HREF=\"index.$ext#$funcnameid\">$funcname()</A></H2>\n\n";
		if (defined($php_functions{$funcname})) {
			print FUNCINDEX "<B>This function is provided by PHP directly.</B><BR>\n";
			print FUNCINDEX "You can lookup the documentation for it here: </B><BR>&nbsp;&nbsp;";
			print FUNCINDEX make_php_doclinks($funcname);
			print FUNCINDEX "<BR><P>\n";
		}
		if (defined($func_definitions{$funcname})) {
			print FUNCINDEX "<B>Defined at..</B><UL>\n";
			foreach $def (@{$func_definitions{$funcname}}) {
				print FUNCINDEX "<LI>";
				print FUNCINDEX "<A HREF=\"..".$def->{'subdir'}."/".$def->{'filename'}.".$ext#$funcnameid\">";
				print FUNCINDEX $def->{'subdir'}."/".$def->{'filename'}."</A> ";
				print FUNCINDEX " -> ";
				print FUNCINDEX "<A HREF=\"..".$def->{'subdir'}."/".$def->{'filename'}.".source.$ext#l".$def->{'line'}."\">";
				print FUNCINDEX " line ".$def->{'line'}."</A>";
				print FUNCINDEX "</LI>\n";
			}
			print FUNCINDEX "</UL>\n";
		}
		if (defined($func_references{$funcname})) {
			print FUNCINDEX "<B>Referenced ".scalar(@{$func_references{$funcname}})." times..</B><UL>\n";
		} else {
			print FUNCINDEX "<B>No references found</B><BR><BR>\n";
		}
		foreach $def (@{$func_references{$funcname}}) {
			print FUNCINDEX "<LI>";
			print FUNCINDEX "<A HREF=\"..".$def->{'subdir'}.$def->{'filename'}.".$ext\">";
			print FUNCINDEX $def->{'subdir'}.$def->{'filename'}."</A> ";
			print FUNCINDEX " -> ";
			print FUNCINDEX "<A HREF=\"..".$def->{'subdir'}.$def->{'filename'}.".source.$ext#l".$def->{'line'}."\">";
			print FUNCINDEX " line ".$def->{'line'}."</A>";
			print FUNCINDEX "</LI>\n";
		}
		print FUNCINDEX "</UL>\n";
		print FUNCINDEX $pagefooter;
		close(FUNCINDEX);
	}
	# Generate function index
	open(INDEX,">$output_dir/_functions/index.$ext") || die "Error opening $output_dir/functions.$ext for write: $!";
	$newheader=$pageheader;
	$newheader =~ s/__TITLE__/Full Function Index/g;
	print INDEX $newheader;
	print INDEX "[<A HREF=\"../index.$ext\">Top level directory</A>] ";
	print INDEX " &nbsp;&nbsp;&nbsp; ";
	print INDEX "[<A HREF=\"../_variables/index.$ext\">Variables</A>]";
	print INDEX " &nbsp;&nbsp;&nbsp; ";
	print INDEX "[<A HREF=\"../_tables/index.$ext\">Tables</A>]";
	print INDEX "<BR>\n";
	print INDEX "<H2>Function List (alphabetical)</H2>\n"; 
	print INDEX "<FONT SIZE=+1>\n";
	print INDEX "Total unique names: <B>".scalar(keys %func_ids)."</B><UL>\n";
	if (defined(@funclist_defs)) {
		print INDEX "<LI><A HREF=\"#DEF\">Functions defined on the site</A>: <B>".scalar(@funclist_defs)."</B></LI>\n";
	}
	if (defined(@funclist_php)) {
		print INDEX "<LI><A HREF=\"#PHP\">PHP functions used on the site</A>: <B>".scalar(@funclist_php)."</B></LI>\n";
	}
	if (defined(@funclist_other)) {
		print INDEX "<LI><A HREF=\"#OTHER\">Undefined functions</A>: <B>".scalar(@funclist_other)."</B></LI>\n";
	}
	print INDEX "</UL>\n";
	print INDEX "</FONT>\n";
	if (scalar(@funclist_defs)) {
		print INDEX "<A HREF=\"#top\" NAME=\"DEF\">";
		print INDEX "<B>Functions defined on the site</B>";
		print INDEX "</A><UL>\n";
		foreach $funcname (@funclist_defs) {
			$funcnameid=$func_ids{$funcname};
			print INDEX "<LI>";
			print INDEX "<A NAME=\"$funcnameid\" HREF=\"$funcnameid.$ext\">$funcname()</A>";
			print INDEX "&nbsp;&nbsp;<FONT SIZE=-1>Definitions: <B>".scalar(@{$func_definitions{$funcname}});
			print INDEX "&nbsp; </B>References: <B>".scalar(@{$func_references{$funcname}})."</B></FONT>";
			print INDEX "</LI>\n";
		}
		print INDEX "</UL><BR>\n";
	}
	if (scalar(@funclist_php)) {
		print INDEX "<A HREF=\"#top\" NAME=\"PHP\">";
		print INDEX "<B>PHP functions used on the site</B>";
		print INDEX "</A><UL>\n";
		foreach $funcname (@funclist_php) {
			$funcnameid=$func_ids{$funcname};
			print INDEX "<LI>";
			print INDEX "<A NAME=\"$funcnameid\" HREF=\"$funcnameid.$ext\">$funcname()</A>";
			print INDEX "&nbsp;&nbsp;<FONT SIZE=-1>References: <B>".scalar(@{$func_references{$funcname}})."</B></FONT>";
			print INDEX "</LI>\n";
		}
		print INDEX "</UL><BR>\n";
	}
	if (scalar(@funclist_other)) {
		print INDEX "<A HREF=\"#top\" NAME=\"OTHER\">";
		print INDEX "<B>Undefined functions</B>";
		print INDEX "</A><BR>\n";
		print INDEX "<I>Most will be bogus functions, triggered by SQL queries etc</I><UL>\n";
		foreach $funcname (@funclist_other) {
			$funcnameid=$func_ids{$funcname};
			print INDEX "<LI>";
			print INDEX "<A NAME=\"$funcnameid\" HREF=\"$funcnameid.$ext\">$funcname()</A>";
			print INDEX "&nbsp;&nbsp;<FONT SIZE=-1>References: <B>".scalar(@{$func_references{$funcname}})."</B></FONT>";
			print INDEX "</LI>\n";
		}
		print INDEX "</UL>\n";
	}
	print INDEX $pagefooter;
	close(INDEX);

	# Generate table references
	print "\nGenerating table references: ";
	mkpath("$output_dir/_tables");
	$f=0;
	foreach $tablename (sort(keys %table_ids)) {
		(!($f % 10)) && (print "."); 
		$f++;
		my  $tablenameid=$table_ids{$tablename};
		open(TABLEINDEX,">$output_dir/_tables/$tablenameid.$ext")|| die "Error opening $output_dir/_tables/$$tablenameid.$ext for write: $!";
		$newheader=$pageheader;
		$newheader =~ s/__TITLE__/Table Reference: $tablename/g;
		print TABLEINDEX $newheader;
		print TABLEINDEX javascript_search(1);
		print TABLEINDEX "[<A HREF=\"../index.$ext\">Top level directory</A>]<BR>\n";
		print TABLEINDEX "<H3>Table Cross Reference</H3>\n";
		print TABLEINDEX "<H2><A HREF=\"index.$ext#$tablenameid\">$tablename</A></H2>\n\n";

		print TABLEINDEX "<B>Referenced ".scalar(@{$table_references{$tablename}})." times..</B><UL>\n";
		foreach $def (@{$table_references{$tablename}}) {
			print TABLEINDEX "<LI>";
			print TABLEINDEX "<A HREF=\"..".$def->{'subdir'}.$def->{'filename'}.".$ext\">";
			print TABLEINDEX $def->{'subdir'}.$def->{'filename'}."</A> ";
			print TABLEINDEX " -> ";
			print TABLEINDEX "<A HREF=\"..".$def->{'subdir'}.$def->{'filename'}.".source.$ext#l".$def->{'line'}."\">";
			print TABLEINDEX " line ".$def->{'line'}."</A>";
			print TABLEINDEX "</LI>\n";
		}
		print TABLEINDEX "</UL>\n";

		print TABLEINDEX "<H3>Table Description</H3>\n";

		if ($dbh != 0)
		{
			my $sth = $dbh->prepare("describe $tablename");
			$sth->execute;
			my $numRows = $sth->rows;

			#print "ROWS = $numRows\n";

			if ($numRows > 0)
			{
				print TABLEINDEX "<table border=1>";

				while (my @row = $sth->fetchrow_array())
				{
					print TABLEINDEX "<tr>";

					foreach my $col (@row)
						{
							$col = "&nbsp;" unless defined $col;
							$col = "&nbsp;" if ($col eq "");

							print TABLEINDEX "<td>$col</td>";
						}

					print TABLEINDEX "</tr>\n";
				}
				print TABLEINDEX "</table>";
			}

			$sth->finish;
		}
		else
		{
			print TABLEINDEX "Table description not available!<br><br>";
		}
		
		print TABLEINDEX $pagefooter;
	}
	# Generate table index
	open(INDEX,">$output_dir/_tables/index.$ext") || die "Error opening $output_dir/tables/index.$ext for write: $!";
	$newheader=$pageheader;
	$newheader =~ s/__TITLE__/Full Table Index/g;
	print INDEX $newheader;
	print INDEX "[<A HREF=\"../index.$ext\">Top level directory</A>] ";
	print INDEX " &nbsp;&nbsp;&nbsp; ";
	print INDEX "[<A HREF=\"../_functions/index.$ext\">Functions</A>] ";
	print INDEX " &nbsp;&nbsp;&nbsp; ";
	print INDEX "[<A HREF=\"../_variables/index.$ext\">Variables</A>]<BR>";
	print INDEX "<H2>Table List (alphabetical)</H2>\n"; 
	print INDEX "<FONT SIZE=+1>\n";
	print INDEX "Total unique names: <B>".scalar(keys %table_ids)."</B><BR>\n";
	print INDEX "<P><B>Tables referenced on the site</B><BR>";
	print INDEX "</FONT>";
	print INDEX "<UL>\n";
	foreach $tablename (sort keys %table_references) {
		$tablenameid=$table_ids{$tablename};
		print INDEX "<LI>";
		print INDEX "<A NAME=\"$tablenameid\" HREF=\"$tablenameid.$ext\">$tablename</A>";
		print INDEX "&nbsp;&nbsp;<FONT SIZE=-1>References: <B>".scalar(@{$table_references{$tablename}})."</B></FONT>";
		print INDEX "</LI>\n";
	}
	print INDEX "</UL><BR>\n";

	print INDEX $pagefooter;
	close(INDEX);
}


# Format a string for html
sub formatstr {
	$_=shift;

	s|&|&amp;|g;
	s|<|&lt;|g;
	s|>|&gt;|g;
	s|\"|&quot;|g;
	s|\n|<BR>\n|g;
	s|^(\t+)|"&nbsp;" x (length($&)*8)|eg;
	s|^([ ]+)|"&nbsp;" x length($&)|eg;

	return($_);
}

sub getdepth {
	my $dir=shift;
	$dir =~ s|/+|/|g;
	$dir =~ s|/$||;
	$dir =~ s|^/||;
	return(0) unless length($dir);
	$dir =~ s|[^/]+||g;
	return(length($dir)+1);
}

sub uri_encode {
	my $str=shift;
	$str =~ s/([" %&+<=>"])/sprintf '%%%.2X' => ord $1/eg;
	return $str;
}

sub usage_die {
	my $error=shift;

	print "Usage: phpxref [-c <config filename>]\n\n";
	print "Error: $error\n\n" unless (!defined($error));

	exit 1;
}

sub read_functions {
	my $filename=shift;

	open(FUNCTIONS,$filename) || die "Error opening $filename: $!";
	while(<FUNCTIONS>) {
		chomp;
		$php_functions{$_}=1;
	}
	close(FUNCTIONS);
}

sub make_php_doclinks {
	my $func=uri_encode(shift);

	my $link="";
	foreach $host (@phpsites) {
		$link.="[<A HREF=\"http://$host/manual-lookup.php?function=$func\">$host</A>] ";
	}
	return($link);
}

sub parse_config {
	my $filename=shift;
	my ($var,$val);

	open(CONFIG,$filename) || usage_die("Error opening $filename: $!");
	while(<CONFIG>) {
		next if /^\s*#/;
		next unless /(\w+)\s*=\s*(.+)/;
		($var,$val)=(lc $1,$2);
		if ($var eq 'bad_dirname') {
			$bad_dirnames{$val}=1;
		} elsif ($var eq 'bad_pathname') {
			$val =~ s|/+$||;
			$bad_pathnames{$val}=1;
		} elsif ($var eq 'bad_ext') {
			$bad_extensions{$val}=1;
		} elsif ($var eq 'good_ext') {
			$good_extensions{$val}=1;
		} elsif ($var eq 'bad_filename') {
			$bad_filenames{$val}=1;
		} elsif ($var eq 'includepath') {
			foreach $ip (split(/:/,$val)) {
				$ip =~ s|/+$||; # strip trailing slashes
				push(@includepath,$ip);
			}
		} else {
			$config{$var}=$val;
		}
	}
	close(CONFIG);
}


sub javascript_search {
	my $depth=shift;
	my $relbase="../" x $depth;
	my $j=<<__EOS__;
<SCRIPT LANGUAGE="JavaScript">
<!--
ext='.$ext';
relbase='$relbase';
function jump() {
    if (document.search.funcname.value.length) {
		funcname=document.search.funcname.value.replace(/[()]/g,'');
		funcname=document.search.funcname.value.toLowerCase();
        window.location=relbase+'_functions/'+escape(escape(funcname))+ext;
	}
    if (document.search.varname.value.length) {
		varname=document.search.varname.value.replace(/[\$]/g,'');
        window.location=relbase+'_variables/'+escape(escape(varname))+ext;
	}
    if (document.search.tablename.value.length) {
		tablename=document.search.tablename.value.toLowerCase();
        window.location=relbase+'_tables/'+escape(escape(tablename))+ext;
	}
    return false;
}

document.writeln('<TABLE ALIGN="RIGHT" BORDER=0>');
document.writeln('<TR BGCOLOR="$config{'js_bg1'}"><TD>');
document.writeln('<CENTER><FONT SIZE=-1 COLOR="$config{'js_fg1'}"><B>Lookup</B></FONT></CENTER>');
document.writeln('</TD></TR>');

document.writeln('<TR BGCOLOR="$config{'js_bg2'}"><TD ALIGN="RIGHT">');
document.writeln('<FONT SIZE=-1>');
document.writeln('<FORM NAME="search" onSubmit=\\'return jump()\\'>');
document.writeln('<A HREF="${relbase}_functions/index.$ext">Function</A>: ');
document.writeln('<INPUT TYPE="TEXT" SIZE=10 VALUE="" NAME="funcname" onChange=\\'jump()\\'><BR>');
document.writeln('<A HREF="${relbase}_variables/index.$ext">Variable</A>: ');
document.writeln('<INPUT TYPE="TEXT" SIZE=10 VALUE="" NAME="varname" onChange=\\'jump()\\'><BR>');
document.writeln('<A HREF="${relbase}_tables/index.$ext">Table</A>: ');
document.writeln('<INPUT TYPE="TEXT" SIZE=10 VALUE="" NAME="tablename" onChange=\\'jump()\\'><BR>');
document.writeln('</FORM>');
document.writeln('</FONT>');
document.writeln('</TD></TR></TABLE>');
// -->
</SCRIPT>
__EOS__
	return($j);
}
